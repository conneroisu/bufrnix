{
  pkgs,
  lib,
  cfg,
  ...
}:
with lib; let
  reactphpEnabled = cfg.reactphp.enable or false;
  swooleEnabled = cfg.swoole.enable or false;
  fibersEnabled = cfg.fibers.enable or false;
  outputPath = cfg.outputPath;
  namespace = cfg.namespace or "Generated";
in {
  # Runtime dependencies for async PHP
  runtimeInputs = [];

  # No additional protoc plugins needed for async support
  protocPlugins = [];

  # Initialization hooks for async PHP
  initHooks = optionalString (reactphpEnabled || swooleEnabled || fibersEnabled) ''
    # Async PHP support initialization
    echo "Setting up async PHP support..."

    # Create async examples directory
    mkdir -p "${outputPath}/Async"

    # ReactPHP support
    ${optionalString reactphpEnabled ''
      if [ ! -f "${outputPath}/Async/ReactPHPClient.php" ]; then
        echo "Creating ReactPHP async client example..."
        cat > "${outputPath}/Async/ReactPHPClient.php" << 'EOF'
      <?php
      /**
       * ReactPHP Async gRPC Client Example
       * Generated by Bufrnix
       */
      namespace ${namespace}\Async;

      use React\EventLoop\Loop;
      use React\Promise\Promise;
      use React\Promise\PromiseInterface;
      use React\Stream\WritableResourceStream;
      use React\Socket\Connector;
      use ${namespace}\ExampleRequest;
      use ${namespace}\ExampleResponse;

      class ReactPHPClient
      {
          private $loop;
          private Connector $connector;
          private string $host;

          public function __construct(string $host = 'localhost:9001')
          {
              $this->host = $host;
              $this->loop = Loop::get();
              $this->connector = new Connector($this->loop);
          }

          /**
           * Send an async request
           */
          public function sendRequestAsync(ExampleRequest $request): PromiseInterface
          {
              return $this->connector
                  ->connect('tcp://' . $this->host)
                  ->then(function ($connection) use ($request) {
                      // Serialize the request
                      $data = $this->encodeMessage($request);
                      $connection->write($data);

                      return $this->readResponse($connection);
                  });
          }

          /**
           * Send multiple requests concurrently
           */
          public function sendBatchAsync(array $requests): PromiseInterface
          {
              $promises = array_map(
                  fn($request) => $this->sendRequestAsync($request),
                  $requests
              );

              return \React\Promise\all($promises);
          }

          /**
           * Stream requests and responses
           */
          public function streamAsync(\Iterator $requests): PromiseInterface
          {
              return new Promise(function ($resolve, $reject) use ($requests) {
                  $this->connector
                      ->connect('tcp://' . $this->host)
                      ->then(function ($connection) use ($requests, $resolve) {
                          $responses = [];

                          // Set up response handler
                          $connection->on('data', function ($data) use (&$responses) {
                              try {
                                  $response = $this->decodeMessage($data, ExampleResponse::class);
                                  $responses[] = $response;
                              } catch (\Exception $e) {
                                  // Continue buffering
                              }
                          });

                          // Send all requests
                          foreach ($requests as $request) {
                              $data = $this->encodeMessage($request);
                              $connection->write($data);
                          }

                          // Close after delay
                          $this->loop->addTimer(1.0, function () use ($connection, $resolve, &$responses) {
                              $connection->close();
                              $resolve($responses);
                          });
                      })
                      ->otherwise($reject);
              });
          }

          /**
           * Read response from connection
           */
          private function readResponse($connection): PromiseInterface
          {
              return new Promise(function ($resolve, $reject) use ($connection) {
                  $buffer = "";

                  $connection->on('data', function ($data) use (&$buffer, $resolve, $reject, $connection) {
                      $buffer .= $data;

                      try {
                          $response = $this->decodeMessage($buffer, ExampleResponse::class);
                          $connection->close();
                          $resolve($response);
                      } catch (\Exception $e) {
                          // Continue buffering if message is incomplete
                          if (strlen($buffer) > 1024 * 1024) { // 1MB limit
                              $connection->close();
                              $reject(new \RuntimeException('Response too large'));
                          }
                      }
                  });

                  $connection->on('error', $reject);
                  $connection->on('close', function () use ($resolve, &$buffer) {
                      if ($buffer === "") {
                          $resolve(null);
                      }
                  });
              });
          }

          /**
           * Encode a protobuf message for transmission
           */
          private function encodeMessage($message): string
          {
              $data = $message->serializeToString();
              // Add length prefix (simplified - real gRPC uses more complex framing)
              return pack('N', strlen($data)) . $data;
          }

          /**
           * Decode a protobuf message from received data
           */
          private function decodeMessage(string $data, string $className)
          {
              if (strlen($data) < 4) {
                  throw new \RuntimeException('Incomplete message');
              }

              $length = unpack('N', substr($data, 0, 4))[1];
              if (strlen($data) < 4 + $length) {
                  throw new \RuntimeException('Incomplete message body');
              }

              $message = new $className();
              $message->mergeFromString(substr($data, 4, $length));

              return $message;
          }

          /**
           * Run the event loop
           */
          public function run(): void
          {
              $this->loop->run();
          }
      }
      EOF
      fi

      # Create ReactPHP server example
      if [ ! -f "${outputPath}/Async/ReactPHPServer.php" ]; then
        cat > "${outputPath}/Async/ReactPHPServer.php" << 'EOF'
      <?php
      /**
       * ReactPHP Async Server Example
       * Generated by Bufrnix
       */
      namespace ${namespace}\Async;

      use React\EventLoop\Loop;
      use React\Socket\SocketServer;
      use React\Stream\WritableResourceStream;
      use ${namespace}\ExampleRequest;
      use ${namespace}\ExampleResponse;

      class ReactPHPServer
      {
          private $loop;
          private SocketServer $socket;
          private $handler;

          public function __construct(string $address = '0.0.0.0:9002', callable $handler = null)
          {
              $this->loop = Loop::get();
              $this->socket = new SocketServer($address, [], $this->loop);
              $this->handler = $handler;
          }

          /**
           * Start the async server
           */
          public function start(): void
          {
              $this->socket->on('connection', function ($connection) {
                  echo "New connection from " . $connection->getRemoteAddress() . "\n";

                  $buffer = "";
                  $connection->on('data', function ($data) use ($connection, &$buffer) {
                      $buffer .= $data;

                      try {
                          // Try to decode a complete message
                          $request = $this->decodeMessage($buffer, ExampleRequest::class);

                          // Process the request
                          $response = $this->handleRequest($request);

                          // Send response
                          $responseData = $this->encodeMessage($response);
                          $connection->write($responseData);

                          // Reset buffer
                          $buffer = substr($buffer, 4 + strlen($request->serializeToString()));

                      } catch (\Exception $e) {
                          // Wait for more data
                      }
                  });

                  $connection->on('error', function ($error) {
                      echo "Connection error: " . $error->getMessage() . "\n";
                  });
              });

              echo "ReactPHP server listening on " . $this->socket->getAddress() . "\n";
              $this->loop->run();
          }

          /**
           * Handle incoming request
           */
          private function handleRequest(ExampleRequest $request): ExampleResponse
          {
              if ($this->handler) {
                  return call_user_func($this->handler, $request);
              }

              // Default handler
              $response = new ExampleResponse();
              $response->setResult("Async processed: " . $request->getData());

              return $response;
          }

          /**
           * Encode a protobuf message
           */
          private function encodeMessage($message): string
          {
              $data = $message->serializeToString();
              return pack('N', strlen($data)) . $data;
          }

          /**
           * Decode a protobuf message
           */
          private function decodeMessage(string $data, string $className)
          {
              if (strlen($data) < 4) {
                  throw new \RuntimeException('Incomplete message');
              }

              $length = unpack('N', substr($data, 0, 4))[1];
              if (strlen($data) < 4 + $length) {
                  throw new \RuntimeException('Incomplete message body');
              }

              $message = new $className();
              $message->mergeFromString(substr($data, 4, $length));

              return $message;
          }
      }
      EOF
      fi
    ''}

    # Swoole/OpenSwoole support
    ${optionalString swooleEnabled ''
      if [ ! -f "${outputPath}/Async/SwooleServer.php" ]; then
        echo "Creating Swoole/OpenSwoole server example..."
        cat > "${outputPath}/Async/SwooleServer.php" << 'EOF'
      <?php
      /**
       * Swoole/OpenSwoole gRPC Server Example
       * Generated by Bufrnix
       */
      namespace ${namespace}\Async;

      use OpenSwoole\Server;
      use OpenSwoole\Coroutine;
      use ${namespace}\ExampleRequest;
      use ${namespace}\ExampleResponse;
      use ${namespace}\Services\ExampleServiceInterface;

      class SwooleGrpcServer
      {
          private Server $server;
          private array $services = [];
          private bool $enableCoroutines;

          public function __construct(
              string $host = '0.0.0.0',
              int $port = 9501,
              bool $enableCoroutines = ${
        if cfg.swoole.coroutines or true
        then "true"
        else "false"
      }
          ) {
              $this->server = new Server($host, $port, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);
              $this->enableCoroutines = $enableCoroutines;

              $this->configureServer();
              $this->registerEventHandlers();
          }

          /**
           * Configure Swoole server
           */
          private function configureServer(): void
          {
              $this->server->set([
                  'worker_num' => 4,
                  'task_worker_num' => 2,
                  'enable_coroutine' => $this->enableCoroutines,
                  'max_coroutine' => 3000,
                  'open_http2_protocol' => true,
                  'log_level' => SWOOLE_LOG_INFO,
                  'hook_flags' => SWOOLE_HOOK_ALL,
              ]);
          }

          /**
           * Register a service implementation
           */
          public function registerService(string $interface, object $implementation): self
          {
              $this->services[$interface] = $implementation;
              return $this;
          }

          /**
           * Register event handlers
           */
          private function registerEventHandlers(): void
          {
              $this->server->on('start', function (Server $server) {
                  echo "Swoole gRPC server started at {$server->host}:{$server->port}\n";
                  echo "Master PID: {$server->master_pid}, Manager PID: {$server->manager_pid}\n";
              });

              $this->server->on('receive', function (Server $server, int $fd, int $reactor_id, string $data) {
                  if ($this->enableCoroutines) {
                      Coroutine::create(function () use ($server, $fd, $data) {
                          $this->handleRequest($server, $fd, $data);
                      });
                  } else {
                      $this->handleRequest($server, $fd, $data);
                  }
              });

              $this->server->on('task', function (Server $server, int $task_id, int $reactor_id, $data) {
                  // Handle async tasks
                  return $this->processTask($data);
              });

              $this->server->on('finish', function (Server $server, int $task_id, $data) {
                  // Task completed
              });
          }

          /**
           * Handle incoming request
           */
          private function handleRequest(Server $server, int $fd, string $data): void
          {
              try {
                  // Parse HTTP/2 frame and extract gRPC message
                  // This is simplified - real implementation needs HTTP/2 parsing
                  $request = new ExampleRequest();
                  $request->mergeFromString($this->extractGrpcMessage($data));

                  // Find and execute service method
                  $response = $this->executeServiceMethod($request);

                  // Send response
                  $responseData = $this->encodeGrpcResponse($response);
                  $server->send($fd, $responseData);

              } catch (\Exception $e) {
                  // Send error response
                  $server->send($fd, $this->encodeGrpcError($e));
              }
          }

          /**
           * Process async task
           */
          private function processTask($data): string
          {
              // Implement async task processing
              if ($this->enableCoroutines) {
                  // Use coroutine for I/O operations
                  $result = Coroutine::create(function () use ($data) {
                      // Simulate async I/O
                      Coroutine::sleep(0.1);
                      return "Task processed: " . json_encode($data);
                  });
              }

              return "Task completed";
          }

          /**
           * Execute service method
           */
          private function executeServiceMethod($request)
          {
              // Find appropriate service and method
              // This is simplified - real implementation needs method routing
              foreach ($this->services as $service) {
                  if (method_exists($service, 'processRequest')) {
                      return $service->processRequest(null, $request);
                  }
              }

              throw new \RuntimeException('No service method found');
          }

          /**
           * Extract gRPC message from HTTP/2 frame
           */
          private function extractGrpcMessage(string $data): string
          {
              // Simplified - real implementation needs HTTP/2 and gRPC framing
              return substr($data, 5); // Skip gRPC message prefix
          }

          /**
           * Encode gRPC response
           */
          private function encodeGrpcResponse($response): string
          {
              $data = $response->serializeToString();
              // Add gRPC message prefix (compressed flag + length)
              return chr(0) . pack('N', strlen($data)) . $data;
          }

          /**
           * Encode gRPC error
           */
          private function encodeGrpcError(\Exception $e): string
          {
              // Simplified error response
              return "grpc-status: 13\r\ngrpc-message: " . $e->getMessage() . "\r\n\r\n";
          }

          /**
           * Start the server
           */
          public function start(): void
          {
              $this->server->start();
          }

          /**
           * Stop the server
           */
          public function stop(): void
          {
              $this->server->shutdown();
          }
      }
      EOF
      fi

      # Create Swoole client example
      if [ ! -f "${outputPath}/Async/SwooleClient.php" ]; then
        cat > "${outputPath}/Async/SwooleClient.php" << 'EOF'
      <?php
      /**
       * Swoole/OpenSwoole gRPC Client Example
       * Generated by Bufrnix
       */
      namespace ${namespace}\Async;

      use OpenSwoole\Coroutine;
      use OpenSwoole\Coroutine\Client;
      use ${namespace}\ExampleRequest;
      use ${namespace}\ExampleResponse;

      class SwooleGrpcClient
      {
          private string $host;
          private int $port;
          private float $timeout;

          public function __construct(string $host = 'localhost', int $port = 9501, float $timeout = 5.0)
          {
              $this->host = $host;
              $this->port = $port;
              $this->timeout = $timeout;
          }

          /**
           * Send request using coroutine
           */
          public function sendRequest(ExampleRequest $request): ?ExampleResponse
          {
              return Coroutine::run(function () use ($request) {
                  $client = new Client(SWOOLE_SOCK_TCP);

                  if (!$client->connect($this->host, $this->port, $this->timeout)) {
                      throw new \RuntimeException('Failed to connect: ' . $client->errMsg);
                  }

                  // Send request
                  $data = $this->encodeRequest($request);
                  if (!$client->send($data)) {
                      throw new \RuntimeException('Failed to send data');
                  }

                  // Receive response
                  $responseData = $client->recv($this->timeout);
                  if ($responseData === false) {
                      throw new \RuntimeException('Failed to receive response');
                  }

                  $client->close();

                  return $this->decodeResponse($responseData);
              });
          }

          /**
           * Send multiple requests concurrently
           */
          public function sendConcurrent(array $requests): array
          {
              return Coroutine::run(function () use ($requests) {
                  $responses = [];
                  $channel = new Coroutine\Channel(count($requests));

                  foreach ($requests as $key => $request) {
                      Coroutine::create(function () use ($request, $key, $channel) {
                          try {
                              $response = $this->sendRequest($request);
                              $channel->push([$key, $response, null]);
                          } catch (\Exception $e) {
                              $channel->push([$key, null, $e]);
                          }
                      });
                  }

                  // Collect responses
                  for ($i = 0; $i < count($requests); $i++) {
                      [$key, $response, $error] = $channel->pop($this->timeout);
                      if ($error) {
                          throw $error;
                      }
                      $responses[$key] = $response;
                  }

                  return $responses;
              });
          }

          /**
           * Stream requests using coroutine channel
           */
          public function streamRequests(\Iterator $requests): \Generator
          {
              $channel = new Coroutine\Channel(10);

              // Producer coroutine
              Coroutine::create(function () use ($requests, $channel) {
                  foreach ($requests as $request) {
                      $channel->push($request);
                  }
                  $channel->close();
              });

              // Consumer coroutine
              while (!$channel->isEmpty() || !$channel->isClosing()) {
                  $request = $channel->pop(0.1);
                  if ($request !== false) {
                      yield $this->sendRequest($request);
                  }
              }
          }

          /**
           * Encode request for transmission
           */
          private function encodeRequest(ExampleRequest $request): string
          {
              $data = $request->serializeToString();
              // Add gRPC message prefix
              return chr(0) . pack('N', strlen($data)) . $data;
          }

          /**
           * Decode response
           */
          private function decodeResponse(string $data): ExampleResponse
          {
              // Skip gRPC message prefix
              $messageData = substr($data, 5);

              $response = new ExampleResponse();
              $response->mergeFromString($messageData);

              return $response;
          }
      }
      EOF
      fi
    ''}

    # PHP 8.1+ Fibers support
    ${optionalString fibersEnabled ''
      if [ ! -f "${outputPath}/Async/FiberHandler.php" ]; then
        echo "Creating PHP Fibers example..."
        cat > "${outputPath}/Async/FiberHandler.php" << 'EOF'
      <?php
      /**
       * PHP 8.1+ Fibers Example for Protobuf Processing
       * Generated by Bufrnix
       */
      namespace ${namespace}\Async;

      use ${namespace}\ExampleRequest;
      use ${namespace}\ExampleResponse;

      class FiberProtobufHandler
      {
          private array $fibers = [];
          private array $results = [];

          /**
           * Process multiple protobuf messages concurrently using Fibers
           */
          public function processConcurrent(array $messages): array
          {
              // Create a fiber for each message
              foreach ($messages as $id => $message) {
                  $this->fibers[$id] = new \Fiber(function () use ($message) {
                      return $this->processMessage($message);
                  });

                  // Start the fiber
                  $this->fibers[$id]->start();
              }

              // Process fibers in rounds
              $completed = [];
              while (count($completed) < count($this->fibers)) {
                  foreach ($this->fibers as $id => $fiber) {
                      if (isset($completed[$id])) {
                          continue;
                      }

                      if ($fiber->isSuspended()) {
                          // Resume suspended fiber
                          $fiber->resume();
                      }

                      if ($fiber->isTerminated()) {
                          // Collect result
                          $this->results[$id] = $fiber->getReturn();
                          $completed[$id] = true;
                      }
                  }

                  // Small delay to prevent busy waiting
                  usleep(1000); // 1ms
              }

              return $this->results;
          }

          /**
           * Process a single message with simulated async operations
           */
          private function processMessage(string $data): string
          {
              // Deserialize request
              $request = new ExampleRequest();
              $request->mergeFromString($data);

              // Simulate async I/O operation
              $this->simulateAsyncOperation("Validating request");

              // Process the request
              $processedData = $this->handleBusinessLogic($request);

              // Simulate another async operation
              $this->simulateAsyncOperation("Storing result");

              // Create response
              $response = new ExampleResponse();
              $response->setResult($processedData);

              return $response->serializeToString();
          }

          /**
           * Simulate an async I/O operation
           */
          private function simulateAsyncOperation(string $operation): void
          {
              // In a real application, this would be an actual I/O operation
              // For now, we just suspend the fiber
              \Fiber::suspend($operation);
          }

          /**
           * Handle business logic
           */
          private function handleBusinessLogic(ExampleRequest $request): string
          {
              return "Fiber processed: " . $request->getData();
          }

          /**
           * Create a fiber-based pipeline for message processing
           */
          public function createPipeline(array $stages): \Closure
          {
              return function ($input) use ($stages) {
                  $fiber = new \Fiber(function () use ($input, $stages) {
                      $result = $input;

                      foreach ($stages as $stage) {
                          $result = $stage($result);

                          // Allow other fibers to run
                          \Fiber::suspend();
                      }

                      return $result;
                  });

                  $fiber->start();

                  while (!$fiber->isTerminated()) {
                      $fiber->resume();
                  }

                  return $fiber->getReturn();
              };
          }

          /**
           * Batch process with rate limiting using Fibers
           */
          public function batchProcessWithRateLimit(array $messages, int $maxConcurrent = 10): \Generator
          {
              $active = [];
              $messageQueue = $messages;

              while (!empty($messageQueue) || !empty($active)) {
                  // Start new fibers up to the limit
                  while (count($active) < $maxConcurrent && !empty($messageQueue)) {
                      $id = key($messageQueue);
                      $message = array_shift($messageQueue);

                      $fiber = new \Fiber(function () use ($message) {
                          return $this->processMessage($message);
                      });

                      $fiber->start();
                      $active[$id] = $fiber;
                  }

                  // Check for completed fibers
                  foreach ($active as $id => $fiber) {
                      if ($fiber->isSuspended()) {
                          $fiber->resume();
                      }

                      if ($fiber->isTerminated()) {
                          yield $id => $fiber->getReturn();
                          unset($active[$id]);
                      }
                  }

                  // Small delay
                  usleep(1000);
              }
          }
      }

      /**
       * Example of using Fibers with gRPC-like request handling
       */
      class FiberGrpcHandler
      {
          private array $handlers = [];

          /**
           * Register a method handler
           */
          public function register(string $method, callable $handler): void
          {
              $this->handlers[$method] = $handler;
          }

          /**
           * Handle incoming request using Fibers
           */
          public function handleRequest(string $method, $request): mixed
          {
              if (!isset($this->handlers[$method])) {
                  throw new \RuntimeException("Unknown method: $method");
              }

              $fiber = new \Fiber($this->handlers[$method]);
              $result = $fiber->start($request);

              // Handle fiber suspensions (for async operations)
              while ($fiber->isSuspended()) {
                  // In a real implementation, this would handle async I/O
                  $fiber->resume();
              }

              return $fiber->getReturn();
          }

          /**
           * Handle streaming requests
           */
          public function handleStream(string $method, \Iterator $requests): \Generator
          {
              $handler = $this->handlers[$method] ?? null;
              if (!$handler) {
                  throw new \RuntimeException("Unknown method: $method");
              }

              foreach ($requests as $request) {
                  $fiber = new \Fiber(function () use ($handler, $request) {
                      return $handler($request);
                  });

                  $fiber->start();

                  while (!$fiber->isTerminated()) {
                      if ($fiber->isSuspended()) {
                          $fiber->resume();
                      }
                  }

                  yield $fiber->getReturn();
              }
          }
      }
      EOF
      fi
    ''}
  '';

  # Code generation hooks for async PHP
  generateHooks = optionalString (reactphpEnabled || swooleEnabled || fibersEnabled) ''
    # Async PHP post-generation tasks
    echo "Configuring async PHP support..."

    ${optionalString reactphpEnabled ''
      echo "ReactPHP support enabled - example clients and servers created"
      echo "Install ReactPHP: composer require react/event-loop react/socket react/promise"
      echo ""
    ''}

    ${optionalString swooleEnabled ''
      echo "Swoole/OpenSwoole support enabled - high-performance server examples created"
      echo "Install Swoole: pecl install openswoole"
      echo "Or via Composer: composer require openswoole/core"
      echo ""
    ''}

    ${optionalString fibersEnabled ''
      echo "PHP Fibers support enabled - requires PHP 8.1+"
      echo "Fiber examples for concurrent processing created"
      echo ""
    ''}

    echo "Async PHP examples are in: ${outputPath}/Async/"
  '';
}
